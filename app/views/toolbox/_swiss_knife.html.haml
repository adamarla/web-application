
-#
  The point of this structure is to provide a customizable, re-usable element
  that fits into many situations - thereby reducing code complexity

  This particular element - the swiss-knife - has within it the following (in order):
    1. a radio-button
    2. a checkbox 
    3. a text-label
    4. a button 
    5. a <select> ( for difficulty )
    6. a hidden text field, or trojan
  In cases where the list to display is already known, iterate over the DB
  records and render this element. Then, in JS, disable & hide the bits you don't want
  to show in the list. So, if you want to show checkbox instead of a radio-button,
  hide the latter but not the former

- marker = marker.blank? ? 'tbd' : marker
- label = label.blank? ? 'tbd' : label

.blueprint.toolbox.swiss-knife.full-width{ :marker => "#{marker}" }
  %input.left{ :type => :radio, :class => :radio, :marker => "#{marker}", :disabled => true }  
  %input.left{ :type => :checkbox, :class => :checkbox, :disabled => true, 
               :marker => "#{marker}", :name => "checked[#{marker}]" }  
  .label.left= "#{label}"
  %div.micro-ticker.right
  %input.button.right{ :type => :button, :disabled => true }
  %select.right.difficulty.select{ :name => "difficulty[#{marker}]", :disabled => true}
    %option{ :value => 0 }= ""
    %option{ :value => 1 }= "introductory"
    %option{ :value => 2 }= "intermediate"
    %option{ :value => 3 }= "advanced"
  %input.hidden.trojan{ :type => :text, :name => "trojan[#{marker}]" }
